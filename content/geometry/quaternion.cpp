struct Q {
	using T = double;
	T x, y, z, r;
	Q(T r = 0) : x(0), y(0), z(0), r(r) {}
	Q(T x, T y, T z, T r = 0) : x(x), y(y), z(z), r(r){}
	friend bool operator==(const Q& a, const Q& b) {
		return (a - b).abs2() <= 1e-8; }
	friend bool operator!=(const Q& a, const Q& b) {
		return !(a == b); }
	Q operator-() { return Q(-x, -y, -z, -r); }
	Q operator+(const Q& b) const {
		return Q(x + b.x, y + b.y, z + b.z, r + b.r); }
	Q operator-(const Q& b) const {
		return Q(x - b.x, y - b.y, z - b.z, r - b.r); }
	Q operator*(const T& t) const {
		return Q(x * t, y * t, z * t, r * t); }
	Q operator*(const Q& b) const {
		return Q(
			r * b.x + x * b.r + y * b.z - z * b.y,
			r * b.y - x * b.z + y * b.r + z * b.x,
			r * b.z + x * b.y - y * b.x + z * b.r,
			r * b.r - x * b.x - y * b.y - z * b.z
		);
	}
	Q operator/(const Q& b) const {
		return *this * b.inv(); }
	T abs2() const {
		return r * r + x * x + y * y + z * z; }
	T len() const { return sqrt(abs2()); }
	Q conj() const { return Q(-x, -y, -z, r); }
	Q unit() const { return *this * (1.0 / len()); }
	Q inv() const { return conj() * (1.0 / abs2()); }
	friend T dot(Q a, Q b) {
		return a.x * b.x + a.y * b.y + a.z * b.z; }
	friend Q cross(Q a, Q b) {
		return Q(
			a.y * b.z - a.z * b.y,
			a.z * b.x - a.x * b.z,
			a.x * b.y - a.y * b.x
		);
	}
	friend Q rotation_around(Q axis, T angle) {
		return axis.unit() * sin(angle / 2) + cos(angle / 2);
	}
	Q rotated_around(Q axis, T angle) {
		Q u = rotation_around(axis, angle);
		return u * *this / u;
	}
	friend Q rotation_between(Q a, Q b) {
		a = a.unit(), b = b.unit();
		if(a == -b) {
			// degenerate case
			Q ortho;
			if(abs(a.y) > 1e-8) ortho = cross(a, Q(1, 0, 0));
			else ortho = cross(a, Q(0, 1, 0));
			return rotation_around(ortho, pi);
		} else {
			return (a * (a + b)).conj();
		}
	}
};
